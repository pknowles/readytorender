// Copyright (c) 2024 Pyarelal Knowles, MIT License

#pragma once

#include <decodeless/header.hpp>
#include <decodeless/offset_span.hpp>
#include <glm/glm.hpp>
#include <rtr/types.hpp>

namespace rtr {

// Generated by gitversion.cmake
#include <readytorender_gitversion.h>

namespace common {

// TODO: meshlet variant with glm::u8vec3 triangleVertices

// clang-format off
// Calls RTR_ARRAY(type, name)
#define RTR_COMMON_MESH_FOREACH_ARRAY \
    RTR_ARRAY(glm::uvec3, triangleVertices) \
    RTR_ARRAY(glm::vec3,  vertexPositions) \
    RTR_ARRAY(glm::vec3,  vertexNormals) \
    RTR_ARRAY(glm::vec2,  vertexTexCoords0) \
    RTR_ARRAY(glm::vec4,  vertexTangents)
// clang-format on

struct Mesh {
#define RTR_ARRAY(type, name) decodeless::offset_span<const type> name;
    RTR_COMMON_MESH_FOREACH_ARRAY
#undef RTR_ARRAY
};

struct MeshHeader : decodeless::Header {
    static constexpr decodeless::Magic   HeaderIdentifier{"RTR:COMMON:MESH"};
    static constexpr decodeless::Version VersionSupported{1, 0, 0};
    MeshHeader();

    // Blob including meshes and their attributes but not meshNames
    decodeless::offset_span<const std::byte> raw;

    // Pointers to mesh data
    decodeless::offset_span<Mesh> meshes;

    // All mesh attributes concatenated (not 1:1 as some meshes may be missing
    // attributes)
    Mesh all;

    decodeless::offset_span<offset_string> meshNames;
};

inline MeshHeader::MeshHeader()
    : decodeless::Header{
          .identifier = HeaderIdentifier,
          .version = VersionSupported,
          .gitHash = readytorender_GIT_HASH,
      } {}

static_assert(decodeless::VersionedSubHeader<MeshHeader>);

} // namespace common

} // namespace rtr
