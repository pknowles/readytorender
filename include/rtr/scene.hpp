// Copyright (c) 2024 Pyarelal Knowles, MIT License

#pragma once

#include <decodeless/header.hpp>
#include <decodeless/offset_span.hpp>
#include <glm/glm.hpp>
#include <limits>
#include <rtr/types.hpp>

#ifdef near
#undef near
#endif

#ifdef far
#undef far
#endif

namespace rtr {

// Generated by gitversion.cmake
#include <readytorender_gitversion.h>

struct Node {
    // Transform relative to parent (not global)
    glm::mat4 transform = glm::identity<glm::mat4>();

    // This many descendent nodes (children and their children etc.) are
    // immediately after this node. The node after those may be a sibling, if
    // there are any.
    uint32_t descendantCount = std::numeric_limits<uint32_t>::max();

    // This node's parent is at this many places before this node. Can be used
    // to walk up the tree, but in general processing top down would be faster.
    optional_index32 parentOffset;
};

struct Camera {
    uint32_t node = std::numeric_limits<uint32_t>::max();
    float    fov = std::numeric_limits<float>::quiet_NaN();
    float    near = std::numeric_limits<float>::quiet_NaN();
    float    far = std::numeric_limits<float>::quiet_NaN();
};

struct Instance {
    uint32_t node = std::numeric_limits<uint32_t>::max();
    uint32_t mesh = std::numeric_limits<uint32_t>::max();
    uint32_t material = std::numeric_limits<uint32_t>::max();
};

struct DirectionalLight {
    glm::vec3 illuminance = glm::vec3{1.0f}; // candela per square meter hit ?? lux?
    uint32_t  node = std::numeric_limits<uint32_t>::max();
};

struct PointLight {
    glm::vec3 intensity = glm::vec3{1.0f}; // candela per solid angle ??
    uint32_t  node = std::numeric_limits<uint32_t>::max();
};

struct SpotLight {
    glm::vec3 intensity = glm::vec3{1.0f}; // candela per solid angle ??
    uint32_t  node = std::numeric_limits<uint32_t>::max();
    float     attenuationMax = std::numeric_limits<float>::quiet_NaN();
    float     innerAngle = std::numeric_limits<float>::quiet_NaN();
    float     outerAngle = std::numeric_limits<float>::quiet_NaN();
};

struct MeshLight {
    glm::vec3 luminance = glm::vec3{1.0f}; // candela per source square meter ?? nit?
    uint32_t  node = std::numeric_limits<uint32_t>::max();
    uint32_t  mesh = std::numeric_limits<uint32_t>::max();
};

struct SceneHeader : decodeless::Header {
    static constexpr decodeless::Magic   HeaderIdentifier{"RTR:COMMON:SCENE"};
    static constexpr decodeless::Version VersionSupported{1, 0, 0};
    SceneHeader();

    // Trees of nodes. All descendents of a node appear immediately after each
    // node.
    decodeless::offset_span<Node> nodes;

    // Root nodes for each scene. There must be at least one.
    decodeless::offset_span<decodeless::offset_ptr<Node>> scenes;

    // Objects attached to nodes. The only thing missing is the mesh, which is
    // referenced in another header.
    decodeless::offset_span<Instance>         instances;
    decodeless::offset_span<Camera>           cameras;
    decodeless::offset_span<offset_string>    cameraNames;
    decodeless::offset_span<DirectionalLight> directionalLights;
    decodeless::offset_span<PointLight>       pointLights;
    decodeless::offset_span<SpotLight>        spotLights;
    decodeless::offset_span<MeshLight>        meshLights;
};

inline SceneHeader::SceneHeader()
    : decodeless::Header{
          .identifier = HeaderIdentifier,
          .version = VersionSupported,
          .gitHash = readytorender_GIT_HASH,
      } {}

static_assert(decodeless::VersionedSubHeader<SceneHeader>);

} // namespace rtr
